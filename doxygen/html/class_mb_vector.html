<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>treeducken: MbVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">treeducken
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_mb_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MbVector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_mb_random.html">MbRandom</a> is a class for generating random variables.  
 <a href="class_mb_vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_mb_random_8h_source.html">MbRandom.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a34994ea552d4d102c8b1f715deb994dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a34994ea552d4d102c8b1f715deb994dc">MbVector</a> (void)</td></tr>
<tr class="memdesc:a34994ea552d4d102c8b1f715deb994dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">null constructor (zero-length vector)  <a href="#a34994ea552d4d102c8b1f715deb994dc">More...</a><br /></td></tr>
<tr class="separator:a34994ea552d4d102c8b1f715deb994dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456d0204f259781913d6c628879a2322"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a456d0204f259781913d6c628879a2322">MbVector</a> (int x)</td></tr>
<tr class="memdesc:a456d0204f259781913d6c628879a2322"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates vector of length n without initializing values  <a href="#a456d0204f259781913d6c628879a2322">More...</a><br /></td></tr>
<tr class="separator:a456d0204f259781913d6c628879a2322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a3ab84a77f584df145f16d1f873042"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#ac0a3ab84a77f584df145f16d1f873042">MbVector</a> (int x, T *a)</td></tr>
<tr class="memdesc:ac0a3ab84a77f584df145f16d1f873042"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates vector of length n as a view of vector a  <a href="#ac0a3ab84a77f584df145f16d1f873042">More...</a><br /></td></tr>
<tr class="separator:ac0a3ab84a77f584df145f16d1f873042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fc5dce7588ec1fe94c5456c15b4ff1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a24fc5dce7588ec1fe94c5456c15b4ff1">MbVector</a> (int x, const T &amp;a)</td></tr>
<tr class="memdesc:a24fc5dce7588ec1fe94c5456c15b4ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates vector of length n initializing all elements with value a  <a href="#a24fc5dce7588ec1fe94c5456c15b4ff1">More...</a><br /></td></tr>
<tr class="separator:a24fc5dce7588ec1fe94c5456c15b4ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9170642bc4f080109660df9eb3f713bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a9170642bc4f080109660df9eb3f713bc">MbVector</a> (const <a class="el" href="class_mb_vector.html">MbVector</a> &amp;A)</td></tr>
<tr class="memdesc:a9170642bc4f080109660df9eb3f713bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates vector of length n sharing data with vector A  <a href="#a9170642bc4f080109660df9eb3f713bc">More...</a><br /></td></tr>
<tr class="separator:a9170642bc4f080109660df9eb3f713bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e7793d625f395232e8d2c1479f065d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#ac1e7793d625f395232e8d2c1479f065d">~MbVector</a> (void)</td></tr>
<tr class="memdesc:ac1e7793d625f395232e8d2c1479f065d"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="#ac1e7793d625f395232e8d2c1479f065d">More...</a><br /></td></tr>
<tr class="separator:ac1e7793d625f395232e8d2c1479f065d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecf672c7a4563b6c1534dfc3a2b3ef5"><td class="memItemLeft" align="right" valign="top"><a id="afecf672c7a4563b6c1534dfc3a2b3ef5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#afecf672c7a4563b6c1534dfc3a2b3ef5">operator T *</a> ()</td></tr>
<tr class="memdesc:afecf672c7a4563b6c1534dfc3a2b3ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">type cast to T pointer <br /></td></tr>
<tr class="separator:afecf672c7a4563b6c1534dfc3a2b3ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6f9b64b62048b36c2ee889bd4e921c"><td class="memItemLeft" align="right" valign="top"><a id="a9c6f9b64b62048b36c2ee889bd4e921c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a9c6f9b64b62048b36c2ee889bd4e921c">operator const T *</a> ()</td></tr>
<tr class="memdesc:a9c6f9b64b62048b36c2ee889bd4e921c"><td class="mdescLeft">&#160;</td><td class="mdescRight">type cast to T pointer for const <br /></td></tr>
<tr class="separator:a9c6f9b64b62048b36c2ee889bd4e921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffe936bb9037ce910da8a095782a929"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mb_vector.html">MbVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a1ffe936bb9037ce910da8a095782a929">operator=</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a1ffe936bb9037ce910da8a095782a929"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator (all elements have the value a)  <a href="#a1ffe936bb9037ce910da8a095782a929">More...</a><br /></td></tr>
<tr class="separator:a1ffe936bb9037ce910da8a095782a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75698d54f82729644619a277606762b"><td class="memItemLeft" align="right" valign="top"><a id="af75698d54f82729644619a277606762b"></a>
<a class="el" href="class_mb_vector.html">MbVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#af75698d54f82729644619a277606762b">operator=</a> (const <a class="el" href="class_mb_vector.html">MbVector</a> &amp;A)</td></tr>
<tr class="memdesc:af75698d54f82729644619a277606762b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assignment operator (shallow copy, elements share data) <br /></td></tr>
<tr class="separator:af75698d54f82729644619a277606762b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2620606cadfa0e0ba937fd4725ac3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a8f2620606cadfa0e0ba937fd4725ac3c">operator==</a> (const <a class="el" href="class_mb_vector.html">MbVector</a> &amp;A) const</td></tr>
<tr class="memdesc:a8f2620606cadfa0e0ba937fd4725ac3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator  <a href="#a8f2620606cadfa0e0ba937fd4725ac3c">More...</a><br /></td></tr>
<tr class="separator:a8f2620606cadfa0e0ba937fd4725ac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013ee5f6f44187dbd1ecbbbd9e8f7785"><td class="memItemLeft" align="right" valign="top"><a id="a013ee5f6f44187dbd1ecbbbd9e8f7785"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a013ee5f6f44187dbd1ecbbbd9e8f7785">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a013ee5f6f44187dbd1ecbbbd9e8f7785"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexing operator (allows reference of data using [] notation) <br /></td></tr>
<tr class="separator:a013ee5f6f44187dbd1ecbbbd9e8f7785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb85893f61c5ff21fb2864a48e2a830a"><td class="memItemLeft" align="right" valign="top"><a id="abb85893f61c5ff21fb2864a48e2a830a"></a>
const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (int i) const</td></tr>
<tr class="separator:abb85893f61c5ff21fb2864a48e2a830a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32339427953f6173daeb55a47098907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mb_vector.html">MbVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#af32339427953f6173daeb55a47098907">ref</a> (const <a class="el" href="class_mb_vector.html">MbVector</a> &amp;A)</td></tr>
<tr class="memdesc:af32339427953f6173daeb55a47098907"><td class="mdescLeft">&#160;</td><td class="mdescRight">indexing operator (allows reference of data using [] notation) (const)  <a href="#af32339427953f6173daeb55a47098907">More...</a><br /></td></tr>
<tr class="separator:af32339427953f6173daeb55a47098907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa32c2ecf3505826f287b20a3ef60cc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_mb_vector.html">MbVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#afa32c2ecf3505826f287b20a3ef60cc1">copy</a> (void) const</td></tr>
<tr class="memdesc:afa32c2ecf3505826f287b20a3ef60cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a copy of another array (deep copy, with separate data elements)  <a href="#afa32c2ecf3505826f287b20a3ef60cc1">More...</a><br /></td></tr>
<tr class="separator:afa32c2ecf3505826f287b20a3ef60cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bda3ea5c35ae194e403888883ad025d"><td class="memItemLeft" align="right" valign="top"><a id="a8bda3ea5c35ae194e403888883ad025d"></a>
<a class="el" href="class_mb_vector.html">MbVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a8bda3ea5c35ae194e403888883ad025d">inject</a> (const <a class="el" href="class_mb_vector.html">MbVector</a> &amp;A)</td></tr>
<tr class="memdesc:a8bda3ea5c35ae194e403888883ad025d"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy the values of elements from one array to another <br /></td></tr>
<tr class="separator:a8bda3ea5c35ae194e403888883ad025d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa74ce55ec03ba4720d4e403dfc6f07"><td class="memItemLeft" align="right" valign="top"><a id="a8fa74ce55ec03ba4720d4e403dfc6f07"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a8fa74ce55ec03ba4720d4e403dfc6f07">dim1</a> (void) const</td></tr>
<tr class="memdesc:a8fa74ce55ec03ba4720d4e403dfc6f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the dimensions of the vector (number of elements of vector) <br /></td></tr>
<tr class="separator:a8fa74ce55ec03ba4720d4e403dfc6f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca53f44c61062378aa857e5a2a12350e"><td class="memItemLeft" align="right" valign="top"><a id="aca53f44c61062378aa857e5a2a12350e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#aca53f44c61062378aa857e5a2a12350e">dim</a> (void) const</td></tr>
<tr class="memdesc:aca53f44c61062378aa857e5a2a12350e"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the dimensions of the vector (number of elements of vector) <br /></td></tr>
<tr class="separator:aca53f44c61062378aa857e5a2a12350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48cfa4fd2383bb5505f9545e60bbfa8"><td class="memItemLeft" align="right" valign="top"><a id="af48cfa4fd2383bb5505f9545e60bbfa8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#af48cfa4fd2383bb5505f9545e60bbfa8">getRefCount</a> (void) const</td></tr>
<tr class="memdesc:af48cfa4fd2383bb5505f9545e60bbfa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of vectors that share the same data <br /></td></tr>
<tr class="separator:af48cfa4fd2383bb5505f9545e60bbfa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af68c1d86ed75dc29fdd7eb9070b751a3"><td class="memItemLeft" align="right" valign="top"><a id="af68c1d86ed75dc29fdd7eb9070b751a3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#af68c1d86ed75dc29fdd7eb9070b751a3">size</a> () const</td></tr>
<tr class="memdesc:af68c1d86ed75dc29fdd7eb9070b751a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the number of elements of the vector <br /></td></tr>
<tr class="separator:af68c1d86ed75dc29fdd7eb9070b751a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac80a49eb5c2cfc07e264f049530d14d0"><td class="memItemLeft" align="right" valign="top"><a id="ac80a49eb5c2cfc07e264f049530d14d0"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#ac80a49eb5c2cfc07e264f049530d14d0">v</a></td></tr>
<tr class="memdesc:ac80a49eb5c2cfc07e264f049530d14d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to values <br /></td></tr>
<tr class="separator:ac80a49eb5c2cfc07e264f049530d14d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a190e77a423352dbfcd566ca3cfcc3ea9"><td class="memItemLeft" align="right" valign="top"><a id="a190e77a423352dbfcd566ca3cfcc3ea9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#a190e77a423352dbfcd566ca3cfcc3ea9">n</a></td></tr>
<tr class="memdesc:a190e77a423352dbfcd566ca3cfcc3ea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements <br /></td></tr>
<tr class="separator:a190e77a423352dbfcd566ca3cfcc3ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffe4fea3e516a528aa7f17db3424e53"><td class="memItemLeft" align="right" valign="top"><a id="aaffe4fea3e516a528aa7f17db3424e53"></a>
int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_mb_vector.html#aaffe4fea3e516a528aa7f17db3424e53">refCount</a></td></tr>
<tr class="memdesc:aaffe4fea3e516a528aa7f17db3424e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of references to the vector <br /></td></tr>
<tr class="separator:aaffe4fea3e516a528aa7f17db3424e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class MbVector&lt; T &gt;</h3>

<p><a class="el" href="class_mb_random.html">MbRandom</a> is a class for generating random variables. </p>
<p>Vector class.</p>
<p><a class="el" href="class_mb_random.html">MbRandom</a> is a class that works with random variables. On creating an instance of this class, a seed for a uniform random number is initialized. One can then obtain random variables with different probability distributions, by transforming a uniform(0,1) random variable in different ways. The class can either be instantiated with a long integer, in which case the seed is set to the long integers value (i.e., the class takes on a user-supplied seed) or the class can be instantiated with no value passed in, in which case the seed is initialized using the system time. The class also has functions for calculating the probability or probability density for a random variable or for calculating the quantiles of a probability distribution.</p>
<p>MrBayes templated vector type. We used the Template Numerical Toolkit (TNT) code as a model for this class. TNT vectors are similar to the LAPACk vector type. The TNT code comes with the following disclaimer:</p>
<p>"Template Numerical Toolkit (TNT)</p>
<p>Mathematical and Computational Sciences Division National Institute of Technology, Gaithersburg, MD USA</p>
<p>This software was developed at the National Institute of Standards and Technology (NIST) by employees of the Federal Government in the course of their official duties. Pursuant to title 17 Section 105 of the United States Code, this software is not subject to copyright protection and is in the public domain. NIST assumes no responsibility whatsoever for its use by other parties, and makes no guarantees, expressed or implied, about its quality, reliability, or any other characteristic."</p>
<p>This header file provides a one-dimensional, numerical array which looks like a conventional C array. Elements are accessed via the familiar A[i] notation.</p>
<p>Array assignment is by reference (i.e. shallow assignment). That is, B=A implies that the A and B point to the same array, so modifications to the elements of A will be reflected in B. If an independent copy is required, then B = A.copy() can be used. Note that this facilitates returning arrays from functions without relying on compiler optimizations to eliminate extensive data copying.</p>
<p>The indexing and layout of this array object makes it compatible with C and C++ algorithms that utilize the familiar C[i] notation. This includes numerous textbooks, such as Numercial Recipes, and various public domain codes.</p>
<p>This class employs its own garbage collection via the use of reference counts. That is, whenever an internal array storage no longer has any references to it, it is destroyed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a34994ea552d4d102c8b1f715deb994dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34994ea552d4d102c8b1f715deb994dc">&#9670;&nbsp;</a></span>MbVector() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::<a class="el" href="class_mb_vector.html">MbVector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>null constructor (zero-length vector) </p>
<p>Null constructor.</p>
<p>Null constructor. Creates a 0-length (NULL) vector. Note that the reference count will be set to 1 for this null vector. This is to simplify the rest of the code at the cost of allocating and deleting an int everytime a null vector is needed. </p>

</div>
</div>
<a id="a456d0204f259781913d6c628879a2322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456d0204f259781913d6c628879a2322">&#9670;&nbsp;</a></span>MbVector() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::<a class="el" href="class_mb_vector.html">MbVector</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates vector of length n without initializing values </p>
<p>Constructor of uninitialized vector.</p>
<p>Create a new vector of length n, without initializing vector elements. If x is not positive, a null vector is created. Note that the reference count will be set to 1 regardless of whether we create a null vector. This is to simplify the rest of the code at the cost of allocating and deleting an int every time a null vector is needed.</p>
<p>This version avoids the O(n) initialization overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Dimension (length) of new vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0a3ab84a77f584df145f16d1f873042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a3ab84a77f584df145f16d1f873042">&#9670;&nbsp;</a></span>MbVector() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::<a class="el" href="class_mb_vector.html">MbVector</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates vector of length n as a view of vector a </p>
<p>Create a new x-length vector as a view of an existing one-dimensional C array. The storage for this pre-existing array will never be destroyed by the <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a> class since the reference count is set to 2. When the field is lost by <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a>, the reference count will still be 1 and the field is not garbage collected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The dimension (length) of the new vector </td></tr>
    <tr><td class="paramname">a</td><td>Pointer to C array used as data storage </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24fc5dce7588ec1fe94c5456c15b4ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fc5dce7588ec1fe94c5456c15b4ff1">&#9670;&nbsp;</a></span>MbVector() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::<a class="el" href="class_mb_vector.html">MbVector</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates vector of length n initializing all elements with value a </p>
<p>Constructor of initialized vector.</p>
<p>Constructor, which creates a vector with x elements. The elements will be initialized to the constant specified by the second argument. Most often used to create a vector of zeros, as in <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a> A(n, 0.0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Number of elements. </td></tr>
    <tr><td class="paramname">a</td><td>Value for initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9170642bc4f080109660df9eb3f713bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9170642bc4f080109660df9eb3f713bc">&#9670;&nbsp;</a></span>MbVector() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::<a class="el" href="class_mb_vector.html">MbVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates vector of length n sharing data with vector A </p>
<p>Shallow copy constructor.</p>
<p>Copy constructor, which creates a shallow copy of the <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a> argument. Vector data are not copied but shared. Thus, in <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a> B(A), subsequent changes to A will be reflected by changes in B. For an independent copy, use <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a> B(A.copy()), or B = A.copy(), instead. Note the use of garbage collection in this class, through the reference counter refCount.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Vector to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1e7793d625f395232e8d2c1479f065d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e7793d625f395232e8d2c1479f065d">&#9670;&nbsp;</a></span>~MbVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::~<a class="el" href="class_mb_vector.html">MbVector</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destructor </p>
<p>Destructor with garbage collection.</p>
<p>Destructor. Note that refCount is decreased and only if refCount reaches 0 do we delete allocated memory. This is garbage collection as implemented in JAVA and other languages. Note that null vectors also have a reference count allocated, so that we can always access the value of refCount. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afa32c2ecf3505826f287b20a3ef60cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa32c2ecf3505826f287b20a3ef60cc1">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt; <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::copy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a copy of another array (deep copy, with separate data elements) </p>
<p>Create independent copy.</p>
<p>Create a new version of an existing vector. Used in B = A.copy() or in the construction of a new vector that does not share data with the copied vector, e.g. in <a class="el" href="class_mb_vector.html" title="MbRandom is a class for generating random variables.">MbVector</a> B(A.copy()).</p>
<dl class="section return"><dt>Returns</dt><dd>Copy of this. </dd></dl>

</div>
</div>
<a id="a1ffe936bb9037ce910da8a095782a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffe936bb9037ce910da8a095782a929">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt; &amp; <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assignment operator (all elements have the value a) </p>
<p>Assign scalar to all elements.</p>
<p>Assign all elements of the vector the value of the constant scalar a.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Scalar used in assignment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Assigned vector </dd></dl>

</div>
</div>
<a id="a8f2620606cadfa0e0ba937fd4725ac3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2620606cadfa0e0ba937fd4725ac3c">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>equality operator </p>
<p>Equality operator.</p>
<p>Equality operator. The dimensions of the two vectors are first compared. If it is not the same, then false is returned. Second, all elements are compared. If they are the same, true is returned, otherwise false is returned. Note that this operator is not useful for float and double vectors, but it is handy for int and bool vectors, as well as for vectors of other types that have a sensible operator!= defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Vector to compare this to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this==A, false otherwise. </dd></dl>

</div>
</div>
<a id="af32339427953f6173daeb55a47098907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32339427953f6173daeb55a47098907">&#9670;&nbsp;</a></span>ref()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt; &amp; <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt;::ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_mb_vector.html">MbVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>indexing operator (allows reference of data using [] notation) (const) </p>
<p>Make this reference to A.</p>
<p>creates a reference to another array (shallow copy)</p>
<p>Create a reference (shallow assignment) to another existing vector. In B.ref(A), B and A share the same data and subsequent changes to the vector elements of one will be reflected in the other. Note that the reference counter is always allocated, even for null vectors, so we need not test whether refCount is NULL.</p>
<p>This is what operator= calls, and B=A and B.ref(A) are equivalent operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Vector to take reference of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector for which reference was set to A </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_mb_random_8h_source.html">MbRandom.h</a></li>
<li>src/<a class="el" href="_mb_vector_8h_source.html">MbVector.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
